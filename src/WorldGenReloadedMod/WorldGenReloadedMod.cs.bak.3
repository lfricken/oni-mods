using Harmony;
using Klei;
using Newtonsoft.Json.Linq;
using ProcGen;
using ProcGen.Noise;
using ProcGenGame;
using STRINGS;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using WorldGenReloadedMod;
using static GeyserGenericConfig;

namespace WorlGenReloadedMod
{


    internal class WorldGenReloadedData
    {
        public static List<GeyserPrefabParams> GeyserPrefabParams = new List<GeyserPrefabParams>();
        public static WorldGenReloadedState Config = WorldGenReloadedState.StateManager.State;
        public static ProcGen.World World = null;
        public static List<GeyserPrefabParams> Configs = null;
        public static Dictionary<string, GeyserState> GeyserConfig = new Dictionary<string, GeyserState>();
        public static int GeyserCount = 0;

        public static Dictionary<string, Dictionary<string, int>> CalculatedGeysers = new Dictionary<string, Dictionary<string, int>>();

        public static GeyserPrefabParams? FindGeyserPrefab(string key)
        {
            foreach (GeyserPrefabParams prefab in GeyserPrefabParams)
            {
                if (prefab.geyserType.id.Equals(key))
                    return prefab;
            }
            return null;
        }


        public static SubWorld GetSubWorldFromType(SubWorld.ZoneType type)
        {
            if (World.Zones == null) return null;
            foreach (var sub in World.Zones)
            {
                if (sub.Value.zoneType.Equals(type))
                    return sub.Value;
            }
            return null;
        }

        public static void CalculateGeysers(SeededRandom rnd)
        {
            Dictionary<string, Dictionary<string, int>> calculatedGeysers = new Dictionary<string, Dictionary<string, int>>();
            foreach (KeyValuePair<string, GeyserState> data in WorldGenReloadedData.GeyserConfig)
            {

                int geyserCount = rnd.RandomRange(data.Value.Minimum, data.Value.Maximum + 1);

                string[] subworlds = data.Value.SubWorlds;
                subworlds.ShuffleSeeded(rnd.RandomSource());

                for (int i = 0; i < geyserCount; i++)
                {
                    string subworld = subworlds[i % subworlds.Length];

                    if (!calculatedGeysers.ContainsKey(subworld))
                        calculatedGeysers[subworld] = new Dictionary<string, int>();
                    if (!calculatedGeysers[subworld].ContainsKey(data.Key))
                    {
                        calculatedGeysers[subworld][data.Key] = 0;
                    }
                    calculatedGeysers[subworld][data.Key]++;
                }

            }

            Debug.Log("Calculated Geysers: ");
            foreach (KeyValuePair<string, Dictionary<string, int>> subworld in calculatedGeysers)
            {
                Debug.Log(subworld.Key);
                foreach (KeyValuePair<string, int> geyser in subworld.Value)
                {
                    Debug.Log(geyser.Key + " = " + geyser.Value);
                }
            }
            WorldGenReloadedData.CalculatedGeysers = calculatedGeysers;
        }
    }


    [HarmonyPatch(typeof(WorldGen), "RenderOffline")]
    internal class WorldGenReloadedMod_WorldGen_RenderOffline
    {
        private static FieldInfo successCallbackFnF = AccessTools.Field(typeof(WorldGen), "successCallbackFn");
        private static FieldInfo myRandomF = AccessTools.Field(typeof(WorldGen), "myRandom");
        private static FieldInfo runningF = AccessTools.Field(typeof(WorldGen), "running");
        private static FieldInfo dataF = AccessTools.Field(typeof(WorldGen), "data");
        private static FieldInfo errorCallbackF = AccessTools.Field(typeof(WorldGen), "errorCallback");
        private static MethodInfo SpawnMobsAndTemplatesM = AccessTools.Method(typeof(WorldGen), "SpawnMobsAndTemplates");
        private static MethodInfo PlaceTemplateSpawnersM = AccessTools.Method(typeof(WorldGen), "PlaceTemplateSpawners");

        private static bool Prefix(WorldGen __instance, ref Sim.Cell[] __result, bool doSettle, ref Sim.DiseaseCell[] dc)
        {
            WorldGen.OfflineCallbackFunction successCallbackFn = ((WorldGen.OfflineCallbackFunction)successCallbackFnF.GetValue(__instance));
            SeededRandom myRandom = ((SeededRandom)myRandomF.GetValue(__instance));
            Data data = ((Data)dataF.GetValue(null));
            Action<OfflineWorldGen.ErrorInfo> errorCallback = ((Action<OfflineWorldGen.ErrorInfo>)errorCallbackF.GetValue(__instance));


            Sim.Cell[] cells = null;
            float[] bgTemp = null;
            dc = null;
            HashSet<int> borderCells = new HashSet<int>();
            //CompleteLayout(successCallbackFn);
            __instance.CompleteLayout(successCallbackFn);
            //WriteOverWorldNoise(successCallbackFn);
            WorldGen.WriteOverWorldNoise(successCallbackFn);
            if (!WorldGen.RenderToMap(successCallbackFn, ref cells, ref bgTemp, ref dc, ref borderCells))
            {
                successCallbackFn(UI.WORLDGEN.FAILED.key, -100f, WorldGenProgressStages.Stages.Failure);
                __result = null;
                return false;
            }
            WorldGen.EnsureEnoughAlgaeInStartingBiome(cells);
            List<KeyValuePair<Vector2I, TemplateContainer>> list = new List<KeyValuePair<Vector2I, TemplateContainer>>();
            TemplateContainer baseStartingTemplate = TemplateCache.GetBaseStartingTemplate();
            List<TerrainCell> terrainCellsForTag = WorldGen.GetTerrainCellsForTag(WorldGenTags.StartLocation);
            foreach (TerrainCell item5 in terrainCellsForTag)
            {
                List<KeyValuePair<Vector2I, TemplateContainer>> list2 = list;
                Vector2 vector = item5.poly.Centroid();
                int a = (int)vector.x;
                Vector2 vector2 = item5.poly.Centroid();
                list2.Add(new KeyValuePair<Vector2I, TemplateContainer>(new Vector2I(a, (int)vector2.y), baseStartingTemplate));
            }

            List<TemplateContainer> list3 = TemplateCache.CollectBaseTemplateAssets("poi/");
            foreach (SubWorld subWorld in WorldGen.Settings.GetSubWorldList())
            {
                if (subWorld.pointsOfInterest != null)
                {
                    ////
                    Dictionary<string, string[]> finalPois = new Dictionary<string, string[]>(subWorld.pointsOfInterest);
                    foreach (string poi in subWorld.pointsOfInterest.Keys)
                    {

                        Debug.Log("[] " + poi.ToLower());
                        if (poi.ToLower().Contains("geyser"))
                        {
                            finalPois.Remove(poi);
                        }
                    }
                    AccessTools.Property(typeof(SubWorld), "pointsOfInterest").SetValue(subWorld, finalPois, null);
                    ////
                    foreach (KeyValuePair<string, string[]> item6 in subWorld.pointsOfInterest)
                    {
                        List<TerrainCell> terrainCellsForTag2 = WorldGen.GetTerrainCellsForTag(subWorld.name.ToTag());
                        for (int num = terrainCellsForTag2.Count - 1; num >= 0; num--)
                        {
                            if (!__instance.IsSafeToSpawnPOI(terrainCellsForTag2[num]))
                            {
                                terrainCellsForTag2.Remove(terrainCellsForTag2[num]);
                            }
                        }
                        if (terrainCellsForTag2.Count > 0)
                        {
                            string template = null;
                            TemplateContainer templateContainer = null;
                            int num2 = 0;
                            while (templateContainer == null && num2 < item6.Value.Length)
                            {
                                template = item6.Value[myRandom.RandomRange(0, item6.Value.Length)];
                                templateContainer = list3.Find((TemplateContainer value) => value.name == template);
                                num2++;
                            }
                            if (templateContainer != null)
                            {
                                list3.Remove(templateContainer);
                                for (int i = 0; i < terrainCellsForTag2.Count; i++)
                                {
                                    TerrainCell terrainCell = terrainCellsForTag2[myRandom.RandomRange(0, terrainCellsForTag2.Count)];
                                    if (!terrainCell.node.tags.Contains(WorldGenTags.POI))
                                    {
                                        if (!(templateContainer.info.size.Y > terrainCell.poly.MaxY - terrainCell.poly.MinY))
                                        {
                                            List<KeyValuePair<Vector2I, TemplateContainer>> list4 = list;
                                            Vector2 vector3 = terrainCell.poly.Centroid();
                                            int a2 = (int)vector3.x;
                                            Vector2 vector4 = terrainCell.poly.Centroid();
                                            list4.Add(new KeyValuePair<Vector2I, TemplateContainer>(new Vector2I(a2, (int)vector4.y), templateContainer));
                                            terrainCell.node.tags.Add(template.ToTag());
                                            terrainCell.node.tags.Add(WorldGenTags.POI);
                                            break;
                                        }
                                        float num3 = templateContainer.info.size.Y - (terrainCell.poly.MaxY - terrainCell.poly.MinY);
                                        float num4 = templateContainer.info.size.X - (terrainCell.poly.MaxX - terrainCell.poly.MinX);
                                        if (terrainCell.poly.MaxY + num3 < (float)Grid.HeightInCells && terrainCell.poly.MinY - num3 > 0f && terrainCell.poly.MaxX + num4 < (float)Grid.WidthInCells && terrainCell.poly.MinX - num4 > 0f)
                                        {
                                            List<KeyValuePair<Vector2I, TemplateContainer>> list5 = list;
                                            Vector2 vector5 = terrainCell.poly.Centroid();
                                            int a3 = (int)vector5.x;
                                            Vector2 vector6 = terrainCell.poly.Centroid();
                                            list5.Add(new KeyValuePair<Vector2I, TemplateContainer>(new Vector2I(a3, (int)vector6.y), templateContainer));
                                            terrainCell.node.tags.Add(template.ToTag());
                                            terrainCell.node.tags.Add(WorldGenTags.POI);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            ////        
            WorldGenReloadedData.CalculateGeysers(myRandom);
            List<TemplateContainer> featuresList = TemplateCache.CollectBaseTemplateAssets("features/");
            foreach (SubWorld subWorld in WorldGen.Settings.GetSubWorldList())
            {
                Debug.Log("Processing zone: "+subWorld.name);                
                if (!WorldGenReloadedData.CalculatedGeysers.ContainsKey(subWorld.name))
                {
                    continue;
                }
                Dictionary<string, int> subworldConfig = WorldGenReloadedData.CalculatedGeysers[subWorld.name];
                
                if (subWorld.pointsOfInterest != null)
                {

                    foreach (KeyValuePair<string, int> item6 in subworldConfig)
                    {
                        Debug.Log("Processing geyser: ["+item6.Key+","+ item6.Value + "]");
                        for (int numGeysers = 0; numGeysers < item6.Value; numGeysers++)
                        {
                            List<TerrainCell> terrainCellsForTag2 = WorldGen.GetTerrainCellsForTag(subWorld.name.ToTag());
                            for (int num = terrainCellsForTag2.Count - 1; num >= 0; num--)
                            {
                                if (!__instance.IsSafeToSpawnPOI(terrainCellsForTag2[num]))
                                {
                                    terrainCellsForTag2.Remove(terrainCellsForTag2[num]);
                                }
                            }
                            if (terrainCellsForTag2.Count > 0)
                            {
                                string template = null;
                                TemplateContainer templateContainer = null;
                                int num2 = 0;
                                /*
                                while (templateContainer == null && num2 < item6.Value.Length)
                                {
                                    template = item6.Value[myRandom.RandomRange(0, item6.Value.Length)];
                                    templateContainer = list3.Find((TemplateContainer value) => value.name == template);
                                    num2++;
                                }
                                */
                                templateContainer = GetGeyserTemplate(featuresList, item6.Key);
                                Debug.Log("Adding geyser: " + templateContainer.name+" ["+item6.Key+"]");
                                if (templateContainer != null)
                                {
                                    //list3.Remove(templateContainer);
                                    for (int i = 0; i < terrainCellsForTag2.Count; i++)
                                    {
                                        TerrainCell terrainCell = terrainCellsForTag2[myRandom.RandomRange(0, terrainCellsForTag2.Count)];
                                        if (!terrainCell.node.tags.Contains(WorldGenTags.POI))
                                        {
                                            if (!(templateContainer.info.size.Y > terrainCell.poly.MaxY - terrainCell.poly.MinY))
                                            {
                                                List<KeyValuePair<Vector2I, TemplateContainer>> list4 = list;
                                                Vector2 vector3 = terrainCell.poly.Centroid();
                                                int a2 = (int)vector3.x;
                                                Vector2 vector4 = terrainCell.poly.Centroid();
                                                list4.Add(new KeyValuePair<Vector2I, TemplateContainer>(new Vector2I(a2, (int)vector4.y), templateContainer));
                                                terrainCell.node.tags.Add(template.ToTag());
                                                terrainCell.node.tags.Add(WorldGenTags.POI);
                                                break;
                                            }
                                            float num3 = templateContainer.info.size.Y - (terrainCell.poly.MaxY - terrainCell.poly.MinY);
                                            float num4 = templateContainer.info.size.X - (terrainCell.poly.MaxX - terrainCell.poly.MinX);
                                            if (terrainCell.poly.MaxY + num3 < (float)Grid.HeightInCells && terrainCell.poly.MinY - num3 > 0f && terrainCell.poly.MaxX + num4 < (float)Grid.WidthInCells && terrainCell.poly.MinX - num4 > 0f)
                                            {
                                                List<KeyValuePair<Vector2I, TemplateContainer>> list5 = list;
                                                Vector2 vector5 = terrainCell.poly.Centroid();
                                                int a3 = (int)vector5.x;
                                                Vector2 vector6 = terrainCell.poly.Centroid();
                                                list5.Add(new KeyValuePair<Vector2I, TemplateContainer>(new Vector2I(a3, (int)vector6.y), templateContainer));
                                                terrainCell.node.tags.Add(template.ToTag());
                                                terrainCell.node.tags.Add(WorldGenTags.POI);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

            }
            ////

            /*
            List<TemplateContainer> list6 = TemplateCache.CollectBaseTemplateAssets("features/");
            foreach (SubWorld subWorld2 in WorldGen.Settings.GetSubWorldList())
            {
                if (subWorld2.featureTemplates != null && subWorld2.featureTemplates.Count > 0)
                {
                    List<string> list7 = new List<string>();
                    foreach (KeyValuePair<string, int> featureTemplate in subWorld2.featureTemplates)
                    {
                        for (int j = 0; j < featureTemplate.Value; j++)
                        {
                            list7.Add(featureTemplate.Key);
                        }
                    }
                    list7.ShuffleSeeded(myRandom.RandomSource());
                    List<TerrainCell> terrainCellsForTag3 = WorldGen.GetTerrainCellsForTag(subWorld2.name.ToTag());
                    terrainCellsForTag3.ShuffleSeeded(myRandom.RandomSource());
                    foreach (TerrainCell item7 in terrainCellsForTag3)
                    {
                        if (list7.Count == 0)
                        {
                            break;
                        }
                        if (__instance.IsSafeToSpawnFeatureTemplate(item7))
                        {
                            string template2 = list7[list7.Count - 1];
                            list7.RemoveAt(list7.Count - 1);
                            TemplateContainer templateContainer2 = list6.Find((TemplateContainer value) => value.name == template2);
                            if (templateContainer2 != null)
                            {
                                List<KeyValuePair<Vector2I, TemplateContainer>> list8 = list;
                                Vector2 vector7 = item7.poly.Centroid();
                                int a4 = (int)vector7.x;
                                Vector2 vector8 = item7.poly.Centroid();
                                list8.Add(new KeyValuePair<Vector2I, TemplateContainer>(new Vector2I(a4, (int)vector8.y), templateContainer2));
                                item7.node.tags.Add(template2.ToTag());
                                item7.node.tags.Add(WorldGenTags.POI);
                            }
                        }
                    }
                }
            }
            */
            foreach (int item8 in borderCells)
            {
                cells[item8].SetValues(WorldGen.unobtaniumElement, ElementLoader.elements);
            }
            if (doSettle)
            {
                //running = WorldGenSimUtil.DoSettleSim(cells, bgTemp, dc, successCallbackFn, data, list, errorCallback, delegate (Sim.Cell[] updatedCells, float[] updatedBGTemp, Sim.DiseaseCell[] updatedDisease)
                runningF.SetValue(null, WorldGenSimUtil.DoSettleSim(cells, bgTemp, dc, successCallbackFn, data, list, errorCallback, delegate (Sim.Cell[] updatedCells, float[] updatedBGTemp, Sim.DiseaseCell[] updatedDisease)
                {
                    //SpawnMobsAndTemplates(updatedCells, updatedBGTemp, updatedDisease, borderCells);
                    SpawnMobsAndTemplatesM.Invoke(__instance, new object[] { updatedCells, updatedBGTemp, updatedDisease, borderCells });
                }));
            }
            foreach (KeyValuePair<Vector2I, TemplateContainer> item9 in list)
            {
                //PlaceTemplateSpawners(item9.Key, item9.Value);
                PlaceTemplateSpawnersM.Invoke(__instance, new object[] { item9.Key, item9.Value });
            }
            for (int num5 = data.gameSpawnData.buildings.Count - 1; num5 >= 0; num5--)
            {
                int item = Grid.XYToCell(data.gameSpawnData.buildings[num5].location_x, data.gameSpawnData.buildings[num5].location_y);
                if (borderCells.Contains(item))
                {
                    data.gameSpawnData.buildings.RemoveAt(num5);
                }
            }
            for (int num6 = data.gameSpawnData.elementalOres.Count - 1; num6 >= 0; num6--)
            {
                int item2 = Grid.XYToCell(data.gameSpawnData.elementalOres[num6].location_x, data.gameSpawnData.elementalOres[num6].location_y);
                if (borderCells.Contains(item2))
                {
                    data.gameSpawnData.elementalOres.RemoveAt(num6);
                }
            }
            for (int num7 = data.gameSpawnData.otherEntities.Count - 1; num7 >= 0; num7--)
            {
                int item3 = Grid.XYToCell(data.gameSpawnData.otherEntities[num7].location_x, data.gameSpawnData.otherEntities[num7].location_y);
                if (borderCells.Contains(item3))
                {
                    data.gameSpawnData.otherEntities.RemoveAt(num7);
                }
            }
            for (int num8 = data.gameSpawnData.pickupables.Count - 1; num8 >= 0; num8--)
            {
                int item4 = Grid.XYToCell(data.gameSpawnData.pickupables[num8].location_x, data.gameSpawnData.pickupables[num8].location_y);
                if (borderCells.Contains(item4))
                {
                    data.gameSpawnData.pickupables.RemoveAt(num8);
                }
            }
            WorldGen.SaveWorldGen();
            successCallbackFn(UI.WORLDGEN.COMPLETE.key, 101f, WorldGenProgressStages.Stages.Complete);
            //running = false;
            runningF.SetValue(null, false);
            __result = cells;
            return false;
        }

        private static TemplateContainer GetGeyserTemplate(List<TemplateContainer> templates, string geyserId)
        {
            
            TemplateContainer geyserTemplate = templates.First();
            foreach (TemplateClasses.Prefab pref in geyserTemplate.otherEntities)
            {
                if (pref.id.Contains("GeyserGeneric"))
                {
                    pref.id = "GeyserGeneric_"+geyserId;
                    pref.location_x = 0;
                    pref.location_y = 0;
                }
            }
            return geyserTemplate;
        }
    }

    [HarmonyPatch(typeof(GeyserGenericConfig), "GenerateConfigs")]
    internal class WorldGenReloadedMod_GeyserGenericConfig_GenerateConfigs
    {

        private static void Postfix(ref List<GeyserPrefabParams> __result)
        {
            Debug.Log(" === WorldGenReloadedMod_GeyserGenericConfig_GenerateConfigs Prefix === ");
            WorldGenReloadedData.GeyserPrefabParams = new List<GeyserPrefabParams>(__result);
           
            //__result.Clear();

            List<GeyserPrefabParams> list = new List<GeyserPrefabParams>();

            // foreach config geyser
            foreach (KeyValuePair<string, Dictionary<string, object>> geyser in WorldGenReloadedData.Config.Geysers)
            {
                Dictionary<string, object> geyserData = geyser.Value;
                GeyserPrefabParams? geyserPrefab = WorldGenReloadedData.FindGeyserPrefab(geyser.Key);
                //int min = 1, max = 1;
                //float probability = 0;
                //string[] subworlds = null;
                GeyserState geyserConfig = new GeyserState(geyser.Key);

                // foreach config attribute
                foreach (KeyValuePair<string, object> attribute in geyserData)
                {
                    Debug.Log(attribute.Key.ToLower());
                    Debug.Log(attribute.Value.GetType());
                    Debug.Log(attribute.Value);


                    switch (attribute.Key.ToLower())
                    {
                        case "properties":
                            //Debug.Log(attribute.Value.GetType());
                            //Debug.Log("attribute.Value: "+attribute.Value);

                            // Set geyser basic properties
                            foreach (JProperty property in (JToken)attribute.Value)
                            {
                                Debug.Log(property.Name);
                                FieldInfo fi = AccessTools.Field(typeof(GeyserConfigurator.GeyserType), property.Name);
                                Debug.Log(fi);
                                fi.SetValue(((GeyserPrefabParams)geyserPrefab).geyserType, (float)property.Value);
                                Debug.Log(property.Name);
                            }
                            break;

                        case "minimum":
                            geyserConfig.Minimum = Convert.ToInt32(attribute.Value);
                            break;
                        case "maximum":
                            geyserConfig.Maximum = Convert.ToInt32(attribute.Value);
                            break;
                        case "probability":
                            geyserConfig.Probability = (float)Convert.ToDouble(attribute.Value);
                            break;
                        case "subworlds":
                            geyserConfig.SubWorlds = ((JArray)attribute.Value).ToObject<string[]>();
                            break;

                        default:
                            break;
                    }

                }
                WorldGenReloadedData.GeyserConfig.Add(geyser.Key, geyserConfig);
                
            }
           
            __result = WorldGenReloadedData.GeyserPrefabParams;
            
        }

        
    }

   

    [HarmonyPatch(typeof(GeyserGenericConfig), "CreatePrefabs")]
    internal class WorldGenReloadedMod_GeyserGenericConfig_CreatePrefabs
    {
       

        private static bool Prefix(ref GeyserGenericConfig __instance, ref List<GameObject> __result)
        {
            Debug.Log(" === WorldGenReloadedMod_GeyserGenericConfig_CreatePrefabs Postfix === ");
            
            return true;
        }
    }
    /*
    [HarmonyPatch(typeof(WorldGenSettings), "GetSubWorldList")]
    internal class WorldGenReloadedMod_WorldGenSettings_GetSubWorldList
    {
       
        private static void Postfix(WorldGenSettings __instance, ref List<SubWorld> __result)
        {
            Debug.Log(" === WorldGenReloadedMod_WorldGenSettings_GetSubWorldList Prefix === ");
            List<SubWorld> result = new List<SubWorld>(__result);

            foreach (SubWorld subworld in result)
            {
                if (!subworld.name.Equals("HotMarsh")) continue;
                subworld.pointsOfInterest.Add("geysers_a",new string[] { "feature_geyser_generic" });
            }

            __result = result;
        }
    }
    */
    
    [HarmonyPatch(typeof(TemplateCache), "CollectBaseTemplateAssets")]
    internal class WorldGenReloadedMod_TemplateCache_CollectBaseTemplateAssets
    {
        private struct ParseTemplateWorkItem : IWorkItem<object>
        {
            public string path;

            public TemplateContainer template;

            public void Run(object shared_data)
            {
                template = YamlIO<TemplateContainer>.LoadFile(path);
            }
        }

        public static List<TemplateContainer> CollectBaseTemplateAssets(string folder = "bases/")
        {
            List<TemplateContainer> list = new List<TemplateContainer>();
            string path = System.IO.Path.Combine((string)AccessTools.Field(typeof(TemplateCache),"baseTemplatePath").GetValue(null), folder);
            string[] files = System.IO.Directory.GetFiles(path, "*.yaml");
            WorkItemCollection<ParseTemplateWorkItem, object> workItemCollection = new WorkItemCollection<ParseTemplateWorkItem, object>();
            workItemCollection.Reset(null);
            string[] array = files;
            foreach (string path2 in array)
            {
                workItemCollection.Add(new ParseTemplateWorkItem
                {
                    path = path2
                });
            }
            GlobalJobManager.Run(workItemCollection);
            for (int j = 0; j < workItemCollection.Count; j++)
            {
                ParseTemplateWorkItem workItem = workItemCollection.GetWorkItem(j);
                if (workItem.template != null)
                {
                    List<TemplateContainer> list2 = list;
                    ParseTemplateWorkItem workItem2 = workItemCollection.GetWorkItem(j);
                    list2.Add(workItem2.template);
                }
            }
            list.Sort(delegate (TemplateContainer x, TemplateContainer y)
            {
                if (y.priority - x.priority == 0)
                {
                    return x.name.CompareTo(y.name);
                }
                return y.priority - x.priority;
            });
            return list;
        }

        /*
        private static bool Prefix(ref List<TemplateContainer> __result, string folder)
        {
            Debug.Log(" === WorldGenReloadedMod_TemplateCache_CollectBaseTemplateAssets Prefix === ");

            List<TemplateContainer> list1 = CollectBaseTemplateAssets(folder);
            List<TemplateContainer> list2 = CollectBaseTemplateAssets("features/");
            foreach (TemplateClasses.Prefab pref in list2.First().otherEntities)
            {
                if (pref.id.Contains("GeyserGeneric"))
                {
                    pref.id = "GeyserGeneric_steam";
                    pref.location_x = 0;
                    pref.location_y = 0;
                }
            }
            __result = list1.Concat(list2).Concat(list2).Concat(list2).ToList();
            foreach (TemplateContainer temp in __result)
                Debug.Log(temp.name);
            return false;
        }
        */

        private static void Postfix(ref List<TemplateContainer> __result, string folder)
        {
            
            Debug.Log(" === WorldGenReloadedMod_TemplateCache_CollectBaseTemplateAssets Postfix === ");        
    }
}
    
    [HarmonyPatch(typeof(ProcGen.World), "LoadZones")]
    internal class WorldGenReloadedMod_World_LoadZones
    {
        //private static FieldInfo ZonesF = AccessTools.Field(typeof(ProcGen.World), "Zones");
        //private static FieldInfo ZoneFilesF = AccessTools.Field(typeof(ProcGen.World), "ZoneFiles");
        private static  FieldInfo ZoneLookupTableF = AccessTools.Field(typeof(ProcGen.World), "ZoneLookupTable");
        
        /*
        private static bool Prefix(ProcGen.World __instance, NoiseTreeFiles noise, string path) {
            Debug.Log(" === WorldGenReloadedMod_World_LoadZones Prefix === ");
            Debug.Log(path);
            WorldGenReloadedData.World = __instance;


            foreach (WeightedName zoneFile in __instance.ZoneFiles)
            {
                SubWorld subWorld = null;
                string text = WorldGenSettings.GetSimpleName(zoneFile.name);
                //Debug.Log(text);
                



                if (zoneFile.overrideName != null && zoneFile.overrideName.Length > 0)
                {
                    text = zoneFile.overrideName;
                }
                //if (!ZoneLookupTable.ContainsKey(text))
                if (!((Dictionary < string, SubWorld > )ZoneLookupTableF.GetValue(__instance)).ContainsKey(text))
                {
                    SubWorldFile subWorldFile = YamlIO<SubWorldFile>.LoadFile(path + zoneFile.name + ".yaml");
                    if (subWorldFile != null)
                    {
                        subWorld = subWorldFile.zone;
 
                        Debug.Log("Zone: " + text);
                        
                        subWorld.featureTemplates["feature_geyser_generic"] = 0;

                        //Debug.Log("Total geysers for subworld: " + subWorld.featureTemplates["feature_geyser_generic"]);
                        //KeyValuePair<string, string[]> leftOne = new KeyValuePair<string, string[]>();
                        if (subWorld.pointsOfInterest != null)
                        {
                            Dictionary<string, string[]> finalPois = new Dictionary<string, string[]>();
                            foreach (KeyValuePair<string, string[]> poi in subWorld.pointsOfInterest)
                            {

                                Debug.Log("[] " + poi.Key.ToLower());
                                if (!poi.Key.ToLower().Contains("geyser"))
                                {
                                    //leftOne = poi;
                                    //Debug.Log("hhhh: "+poi);
                                    finalPois.Add(poi.Key,poi.Value);

                                }
                            }


                            Dictionary<string, int> geysersForSubworld = WorldGenReloadedData.CalculatedGeysers[text];

                            foreach (KeyValuePair<string, int> geyser in geysersForSubworld)
                            {
                                for (int i=0; i<geyser.Value; i++)
                                {
                                    finalPois.Add("geysers_"+i, new string[] { "feature_geyser_generic" });
                                }
                            }

                           
                            //finalPois.Add("geysers_a",new string[] { });

                            //subWorld.pointsOfInterest.Clear();
                            PropertyInfo pi = AccessTools.Property(typeof(SubWorld), "pointsOfInterest");
                            pi.SetValue(subWorld, finalPois, null);
                            //foreach (KeyValuePair<string, string[]> poi in finalPois)
                            //    subWorld.pointsOfInterest.Remove(poi.Key);
                            //subWorld.pointsOfInterest = finalPois;
                            //subWorld.pointsOfInterest.Add(leftOne);
                            Debug.Log("Final pois 2:");
                            foreach (KeyValuePair<string, string[]> poi in subWorld.pointsOfInterest)
                            {
                                Debug.Log(poi.Key);
                            }
                        }
						//

						subWorld.name = text;
                        subWorld.pdWeight = zoneFile.weight;
                        //ZoneLookupTable[text] = subWorld;
                        ((Dictionary<string, SubWorld>)ZoneLookupTableF.GetValue(__instance))[text] = subWorld;
                        noise.LoadTree(subWorld.biomeNoise, path);
                        noise.LoadTree(subWorld.densityNoise, path);
                        noise.LoadTree(subWorld.overrideNoise, path);
                    }
                    else
                    {
                        Debug.LogWarning("WorldGen: Attempting to load zone: " + zoneFile.name + " failed");
                    }
                }
                else
                {
                    subWorld = ((Dictionary<string, SubWorld>)ZoneLookupTableF.GetValue(__instance))[text];
                }
                __instance.Zones[text] = subWorld;
            }
            return false;
        }
        */
    }

    // Hooking for logs
    
    [HarmonyPatch(typeof(WorldGen), "PlaceTemplateSpawners")]
    internal class WorldGenReloadedMod_WorldGen_PlaceTemplateSpawners
    {

        private static void Postfix(Vector2I position, TemplateContainer template)
        {
            Debug.Log(" === WorldGenReloadedMod_WorldGen_PlaceTemplateSpawners Postfix === ");

            Debug.Log(position + " at " + template.name);

            if (template.buildings != null && template.buildings != null && template.buildings.Count > 0)
            {
                Debug.Log("otherEntities: " + template.buildings.Count);
                //foreach (TemplateClasses.Prefab pre in template.buildings)
                //    Debug.Log(pre.id + " " + pre.type + " " + pre.element.ToString());
            }

            if (template.elementalOres != null && template.elementalOres != null && template.elementalOres.Count > 0)
            {
                Debug.Log("otherEntities: " + template.elementalOres.Count);
                //foreach (TemplateClasses.Prefab pre in template.elementalOres)
                //    Debug.Log(pre.id + " " + pre.type + " " + pre.element.ToString());
            }

            if (template.otherEntities != null && template.otherEntities != null && template.otherEntities.Count > 0)
            {
                Debug.Log("otherEntities: " + template.otherEntities.Count);
                //foreach (TemplateClasses.Prefab pre in template.otherEntities)
                //    Debug.Log(pre.id+" "+pre.type+" "+pre.element.ToString());
            }
            //if (template.info != null && template.info.tags != null && template.info.tags.Length > 0)
            //	Debug.Log(template.info.tags[0]);

        }
    }


    [HarmonyPatch(typeof(GeyserGenericConfig), "CreateGeyser")]
    internal class WorldGenReloadedMod_GeyserGenericConfig_CreateGeyser
    {

        private static void Postfix(GameObject __result, string id, string anim, int width, int height, string name, string desc, HashedString presetType)
        {
            Debug.Log(" === WorldGenReloadedMod_GeyserGenericConfig_CreateGeyser Postfix === ");
            Debug.Log(id + ", " + anim + ", " + width + ", " + height + ", " + name + ", " + desc + ", " + presetType);
        }
    }

    

    /*
    list.Add(new GeyserPrefabParams("geyser_gas_steam_kanim", 2, 4, new GeyserConfigurator.GeyserType("steam", SimHashes.Steam, 383.15f, 200f, 2500f, 5f)));            
    list.Add(new GeyserPrefabParams("geyser_gas_steam_hot_kanim", 2, 4, new GeyserConfigurator.GeyserType("hot_steam", SimHashes.Steam, 773.15f, 10f, 100f, 15f)));
    list.Add(new GeyserPrefabParams("geyser_liquid_water_hot_kanim", 4, 2, new GeyserConfigurator.GeyserType("hot_water", SimHashes.Water, 368.15f, 500f, 5000f, 500f)));
    list.Add(new GeyserPrefabParams("geyser_liquid_water_slush_kanim", 4, 2, new GeyserConfigurator.GeyserType("slush_water", SimHashes.DirtyWater, 263.15f, 500f, 5000f, 500f)));
    list.Add(new GeyserPrefabParams("geyser_liquid_water_filthy_kanim", 4, 2, new GeyserConfigurator.GeyserType("filthy_water", SimHashes.DirtyWater, 303.15f, 500f, 5000f, 500f).AddDisease(new SimUtil.DiseaseInfo
    {
        idx = Db.Get().Diseases.GetIndex("FoodPoisoning"),
        count = 20000
    })));
    list.Add(new GeyserPrefabParams("geyser_molten_volcano_small_kanim", 3, 3, new GeyserConfigurator.GeyserType("small_volcano", SimHashes.Magma, 2000f, 100f, 1000f, 150f, 6000f, 12000f, 0.005f, 0.01f)));
    list.Add(new GeyserPrefabParams("geyser_molten_volcano_big_kanim", 3, 3, new GeyserConfigurator.GeyserType("big_volcano", SimHashes.Magma, 2000f, 200f, 2000f, 150f, 6000f, 12000f, 0.005f, 0.01f)));
    list.Add(new GeyserPrefabParams("geyser_liquid_co2_kanim", 4, 2, new GeyserConfigurator.GeyserType("liquid_co2", SimHashes.LiquidCarbonDioxide, 218f, 3f, 30f, 50f)));
    list.Add(new GeyserPrefabParams("geyser_gas_co2_hot_kanim", 2, 4, new GeyserConfigurator.GeyserType("hot_co2", SimHashes.CarbonDioxide, 773.15f, 5f, 50f, 5f)));
    list.Add(new GeyserPrefabParams("geyser_gas_hydrogen_hot_kanim", 2, 4, new GeyserConfigurator.GeyserType("hot_hydrogen", SimHashes.Hydrogen, 773.15f, 5f, 50f, 5f)));
    list.Add(new GeyserPrefabParams("geyser_gas_po2_hot_kanim", 2, 4, new GeyserConfigurator.GeyserType("hot_po2", SimHashes.ContaminatedOxygen, 773.15f, 15f, 180f, 5f)));
    list.Add(new GeyserPrefabParams("geyser_gas_po2_slimy_kanim", 2, 4, new GeyserConfigurator.GeyserType("slimy_po2", SimHashes.ContaminatedOxygen, 333.15f, 15f, 180f, 5f).AddDisease(new SimUtil.DiseaseInfo
    {
        idx = Db.Get().Diseases.GetIndex("SlimeLung"),
        count = 5000
    })));
    list.Add(new GeyserPrefabParams("geyser_gas_chlorine_kanim", 2, 4, new GeyserConfigurator.GeyserType("chlorine_gas", SimHashes.ChlorineGas, 333.15f, 15f, 180f, 5f)));
    list.Add(new GeyserPrefabParams("geyser_gas_methane_kanim", 2, 4, new GeyserConfigurator.GeyserType("methane", SimHashes.Methane, 423.15f, 15f, 180f, 5f)));
    list.Add(new GeyserPrefabParams("geyser_molten_copper_kanim", 3, 3, new GeyserConfigurator.GeyserType("molten_copper", SimHashes.MoltenCopper, 2500f, 50f, 500f, 150f, 480f, 1080f, 0.0166666675f, 0.1f)));
    list.Add(new GeyserPrefabParams("geyser_molten_iron_kanim", 3, 3, new GeyserConfigurator.GeyserType("molten_iron", SimHashes.MoltenIron, 2800f, 50f, 500f, 150f, 480f, 1080f, 0.0166666675f, 0.1f)));
    list.Add(new GeyserPrefabParams("geyser_molten_gold_kanim", 3, 3, new GeyserConfigurator.GeyserType("molten_gold", SimHashes.MoltenGold, 2900f, 50f, 500f, 150f, 480f, 1080f, 0.0166666675f, 0.1f)));
    list.Add(new GeyserPrefabParams("geyser_liquid_oil_kanim", 4, 2, new GeyserConfigurator.GeyserType("oil_drip", SimHashes.CrudeOil, 600f, 1f, 250f, 50f, 600f, 600f, 1f, 1f, 100f, 500f)));
    */


}
